#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int max(int x, int y)
{
    return x > y ? x : y;
}

int main()
{
    int a[100][100]; // всё равно не будешь вводить матрицу бОльших размеров
    int n;
    printf("Size: ");
    scanf_s("%d", &n);

    // ввод матрицы, ну изи
    printf("Input matrix:\n");
    for (int i = 0; i < n; ++i) // читаем каждую строку матрицы
    {
        printf("Row #%d: ", i + 1);
        for (int j = 0; j < n; ++j)
            scanf_s("%d", &a[i][j]); 
    }

    // считаем произведение в тех строках, где нету отрицательных элементов
    // будем считать для каждой строки сразу произведение, а выводить только если
    // там не было отрицательных элементов
    for (int i = 0; i < n; ++i)
    {
        int current_product = 1, // начальное произведение (т.к. любое х * 1 = х)
            no_negatives = 1; // флаг, что в текущей строке нету отрицательных чисел. 
                              // если попадётся отрицательное, мы сюда положим 0
        for (int j = 0; j < n && no_negatives; ++j) // идём по текущей строке. в условии также есть флаг
        {                                           // для того, чтобы мы остановились, как только найдём отрицательное число
            if (a[i][j] < 0) no_negatives = 0; // если текущее меньше нуля - опускаем флаг
            current_product *= a[i][j]; // домножаем произведение на текущий элемент
        }
        if (no_negatives) // если у нас за всю строку так и не нашлось отрицательных, выводим ответ
        {
            printf("Row #%d has no negative numbers. ", i + 1);
            printf("The product of its elements: %d\n", current_product);
        }
    }

    // второе задание
    int max_sum = -INT_MAX; // начальное значение максимальной суммы
    /*
        Для удобства будем сразу по две диагонали проверять.
        Будем перебирать номер строки (а для второй диагонали - столбца),
        с которой начнётся наша текущая диагональ. Сразу посчитаем две суммы
        и положим в ответ максимальную из них.

        Пример. Матрица 5х5.
        "Первую диагональ" я возьму в круглые скобки, а вторую - в квадратные

        такие будут диагонали, если start == 2
         1   2  [3]  4   5
         6   7   8  [9]  1
        (2)  3   4   5  [6]
         7  (8)  9   0   1
         2   3  (4)  5   6
    */
    for (int start = n - 1; start >= 0; --start) // перебираем номер строки или столбца первого элемента
    {
        int sum1 = 0, // сумма для первой диагонали ()
            sum2 = 0; // сумма для второй диагонали []
        for (int i = 0; start + i < n; ++i) // идём по диагоналям. 
            sum1 += a[start + i][i], // текущий элемент первой диагонали
            sum2 += a[i][start + i]; // текущий элемент второй диагонали
        max_sum = max(max_sum, max(sum1, sum2)); // обновляем ответ
    }

    printf("Max sum of diagonals: %d\n", max_sum);

    system("pause");
    return 0;
}